diff -ru openssh-7.4p1.orig/channels.c openssh-7.4p1/channels.c
--- openssh-7.4p1.orig/channels.c	2016-12-19 11:08:26.000000000 -0800
+++ openssh-7.4p1/channels.c	2016-12-19 11:10:47.000000000 -0800
@@ -4375,15 +4375,35 @@
 	 * connection to the real X server.
 	 */
 
-	/* Check if the display is from launchd. */
 #ifdef __APPLE__
-	if (strncmp(display, "/tmp/launch", 11) == 0) {
-		sock = connect_local_xsocket_path(display);
-		if (sock < 0)
-			return -1;
+	/* Check if the display is a path to a socket (as set by launchd). */
+	{
+		char path[PATH_MAX];
+		struct stat sbuf;
+		int is_path_to_socket = 0;
+
+		strlcpy(path, display, sizeof(path));
+		if (0 == stat(path, &sbuf)) {
+			is_path_to_socket = 1;
+		} else {
+			char *dot = strrchr(path, '.');
+			if (dot) {
+				*dot = '\0';
+				/* screen = atoi(dot + 1); */
+				if (0 == stat(path, &sbuf)) {
+					is_path_to_socket=1;
+				}
+			}
+		}
 
-		/* OK, we now have a connection to the display. */
-		return sock;
+		if (is_path_to_socket) {
+			sock = connect_local_xsocket_path(path);
+			if (sock < 0)
+				return -1;
+
+			/* OK, we now have a connection to the display. */
+			return sock;
+		}
 	}
 #endif
 	/*
Only in openssh-7.4p1: channels.c.orig
diff -ru openssh-7.4p1.orig/clientloop.c openssh-7.4p1/clientloop.c
--- openssh-7.4p1.orig/clientloop.c	2016-12-19 11:08:26.000000000 -0800
+++ openssh-7.4p1/clientloop.c	2016-12-19 11:10:47.000000000 -0800
@@ -315,6 +315,10 @@
 	struct stat st;
 	u_int now, x11_timeout_real;
 
+#if __APPLE__
+	int is_path_to_socket = 0;
+#endif /* __APPLE__ */
+
 	*_proto = proto;
 	*_data = data;
 	proto[0] = data[0] = xauthfile[0] = xauthdir[0] = '\0';
@@ -331,6 +335,33 @@
 	}
 
 	if (xauth_path != NULL) {
+#if __APPLE__
+		{
+			/*
+			 * If using launchd socket, remove the screen number from the end
+			 * of $DISPLAY. is_path_to_socket is used later in this function
+			 * to determine if an error should be displayed.
+			 */
+			char path[PATH_MAX];
+			struct stat sbuf;
+
+			strlcpy(path, display, sizeof(path));
+			if (0 == stat(path, &sbuf)) {
+				is_path_to_socket = 1;
+			} else {
+				char *dot = strrchr(path, '.');
+				if (dot) {
+					*dot = '\0';
+					/* screen = atoi(dot + 1); */
+					if (0 == stat(path, &sbuf)) {
+						is_path_to_socket = 1;
+						debug("x11_get_proto: $DISPLAY is launchd, removing screennum");
+						setenv("DISPLAY", path, 1);
+					}
+				}
+			}
+		}
+#endif /* __APPLE__ */
 		/*
 		 * Handle FamilyLocal case where $DISPLAY does
 		 * not match an authorization entry.  For this we
@@ -441,6 +472,9 @@
 		u_int8_t rnd[16];
 		u_int i;
 
+#if __APPLE__
+		if (!is_path_to_socket)
+#endif /* __APPLE__ */
 		logit("Warning: No xauth data; "
 		    "using fake authentication data for X11 forwarding.");
 		strlcpy(proto, SSH_X11_PROTO, sizeof proto);
Only in openssh-7.4p1: clientloop.c.orig
diff -ru openssh-7.4p1.orig/ssh-agent.c openssh-7.4p1/ssh-agent.c
--- openssh-7.4p1.orig/ssh-agent.c	2016-12-19 11:08:26.000000000 -0800
+++ openssh-7.4p1/ssh-agent.c	2016-12-19 11:12:57.000000000 -0800
@@ -71,6 +71,10 @@
 # include <util.h>
 #endif
 
+#ifdef __APPLE_LAUNCHD__
+#include <launch.h>
+#endif
+
 #include "xmalloc.h"
 #include "ssh.h"
 #include "rsa.h"
@@ -1200,6 +1204,9 @@
 main(int ac, char **av)
 {
 	int c_flag = 0, d_flag = 0, D_flag = 0, k_flag = 0, s_flag = 0;
+#ifdef __APPLE_LAUNCHD__
+	int l_flag = 0;
+#endif
 	int sock, fd, ch, result, saved_errno;
 	u_int nalloc;
 	char *shell, *format, *pidstr, *agentsocket = NULL;
@@ -1232,7 +1239,11 @@
 	__progname = ssh_get_progname(av[0]);
 	seed_rng();
 
+#ifdef __APPLE_LAUNCHD__
+	while ((ch = getopt(ac, av, "cDdklsE:a:P:t:")) != -1) {
+#else
 	while ((ch = getopt(ac, av, "cDdksE:a:P:t:")) != -1) {
+#endif
 		switch (ch) {
 		case 'E':
 			fingerprint_hash = ssh_digest_alg_by_name(optarg);
@@ -1252,6 +1263,11 @@
 				fatal("-P option already specified");
 			pkcs11_whitelist = xstrdup(optarg);
 			break;
+#ifdef __APPLE_LAUNCHD__
+		case 'l':
+			l_flag++;
+			break;
+#endif
 		case 's':
 			if (c_flag)
 				usage();
@@ -1283,7 +1299,11 @@
 	ac -= optind;
 	av += optind;
 
+#ifdef __APPPLE_LAUNCHD__
+	if (ac > 0 && (c_flag || k_flag || s_flag || d_flag || D_flag || l_flag))
+#else
 	if (ac > 0 && (c_flag || k_flag || s_flag || d_flag || D_flag))
+#endif
 		usage();
 
 	if (pkcs11_whitelist == NULL)
@@ -1342,6 +1362,53 @@
 	 * Create socket early so it will exist before command gets run from
 	 * the parent.
 	 */
+#ifdef __APPLE_LAUNCHD__
+	if (l_flag) {
+		launch_data_t resp, msg, tmp;
+		size_t listeners_i;
+
+		msg = launch_data_new_string(LAUNCH_KEY_CHECKIN);
+
+		resp = launch_msg(msg);
+
+		if (NULL == resp) {
+			perror("launch_msg");
+			exit(1);
+		}
+		launch_data_free(msg);
+		switch (launch_data_get_type(resp)) {
+		case LAUNCH_DATA_ERRNO:
+			errno = launch_data_get_errno(resp);
+			perror("launch_msg response");
+			exit(1);
+		case LAUNCH_DATA_DICTIONARY:
+			break;
+		default:
+			fprintf(stderr, "launch_msg unknown response");
+			exit(1);
+		}
+		tmp = launch_data_dict_lookup(resp, LAUNCH_JOBKEY_SOCKETS);
+
+		if (NULL == tmp) {
+			fprintf(stderr, "no sockets\n");
+			exit(1);
+		}
+
+		tmp = launch_data_dict_lookup(tmp, "Listeners");
+
+		if (NULL == tmp) {
+			fprintf(stderr, "no known listeners\n");
+			exit(1);
+		}
+
+		for (listeners_i = 0; listeners_i < launch_data_array_get_count(tmp); listeners_i++) {
+			launch_data_t obj_at_ind = launch_data_array_get_index(tmp, listeners_i);
+			new_socket(AUTH_SOCKET, launch_data_get_fd(obj_at_ind));
+		}
+
+		launch_data_free(resp);
+	} else {
+#endif
 	prev_mask = umask(0177);
 	sock = unix_listener(socket_name, SSH_LISTEN_BACKLOG, 0);
 	if (sock < 0) {
@@ -1350,6 +1417,12 @@
 		cleanup_exit(1);
 	}
 	umask(prev_mask);
+#ifdef __APPLE_LAUNCHD__
+	}
+
+	if (l_flag)
+		goto skip2;
+#endif
 
 	/*
 	 * Fork, and have the parent execute the command, if any, or present
@@ -1427,6 +1500,7 @@
 	pkcs11_init(0);
 #endif
 	new_socket(AUTH_SOCKET, sock);
+skip2:
 	if (ac > 0)
 		parent_alive_interval = 10;
 	idtab_init();
